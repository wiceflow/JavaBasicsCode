# 接口与抽象类的一些见解  

先介绍两个会出现的名词 ：

* `is-a` 指的是类的父子继承关系，例如类 A 是另一个类 B 的子类（类 B 是类 A 的父类）
* `can-do` 顾名思义，就是某个类可以做的事（方法）  



## 接口与抽象类存在的意义   

> 既然有了接口为什么还需要抽象类，或者既然有了抽象类为什么还需要接口  



我们知道，定义类的过程就是抽象和封装的过程，而接口与抽象则是对实体类进行更高层次的抽象，仅定义公共行为和特征。接口与抽象类的共同点都是不能被实例化，但可以定义引用变量指向实例对象（我们所说的面向接口编程。  接口中的方法访问控制符默认是 `public abstract`，属性访问控制默认是 `public static final` ，从这点上不难理解，当一个抽象类里面只有抽象方法，那么其实它等同于一个接口。

抽象类是典型的 `is-a` 关系，继承关系中，一个子类只能继承一个父类，而接口是 `can-do` 关系。我们可以这样理解，抽象类是对某一事物进行抽象，是为了继承（这样做的好处有利于代码重用），抽象方法在子类中被实现，更易于拓展。看一下下面这个例子  

```java
public abstract class AbstractAnimal {
    /**
    /* 当我们定义一个通用方法时，可以在抽象类里面实现它，因为动物都会吃东西，所以没有必要由子类实现
    /*（个别想要实现它怎么吃东西的童鞋请走开）
    **/
    protected void eat(){
        System.out.println("i can eat");
    }
}
```



接口体现更多的是一种约束，例如我告诉你，你能做什么而且必须要去做。因为接口中的默认方法是 `public abstract` ,所以接口中的方法必须得在子类中实现（在 `JDK8` 之后允许有 `default` 方法的实现）。例如所有汽车都应该具备刹车制动功能，但每一辆车的刹车距离、制动时间都不一样，所以这个方法应该提取为一个接口，让所有汽车子类都去实现它，在这里 接口更像一份契约，我告诉了你要有什么你就得去做，至于怎么完成我不管。  



## 抽象类与接口的混合使用  

从上面分析来看，好像抽象类可以实现的东西，接口都可以实现，而且抽象类只能单继承，那么为什么抽象类还存在呢？  

我们清楚了接口是一份契约，是一种约束其子类必须做什么的顶级类（接口虽然说是关键字时 interface ，但是编译之后的字节码拓展名还是 `.class`），当希望有一个老大哥统领一群小弟时，定义接口是一个很好的选择，但不是所有小弟都会完全按照老大哥说的来做，例如一个动物接口中，存在着 吃东西、跑、飞、游泳等方法，但又不是所有动物都会飞，这时候抽象类的用处就体现出来了。我们来一下例子  

```java
/**
 * @author BF
 * @date 2019/5/17 11:35
 * 测试接口与抽象类的关系  接口
 * <p> 动物接口 </p>
 */
public interface Animal {
    /** 吃东西 */
    void eat();

    /** 飞 */
    void fly();
    
    /** 叫 */
    void cry();

    /** 跑 */
    void walk();

    /** 说话交流 */
    void speak();
}
```

由代码看出，当我们创建一个人的子类（很明显，人也是动物）去实现这个接口时，人并不会飞，那么我只能在子类实现 `fly()`然后不干什么，标明了我不会飞。当我再创建一个子类 猪 ，很明显猪也不会飞但它也是动物，这时候我又的实现 `fly()` 并且什么都不做。一来一回的就出现了累赘，而且代码也不好看。  



> 我们可以按照纬度定义抽象类去实现接口来划分不同的种类。



```java
/**
 * @author BF
 * @date 2019/5/17 14:51
 * 测试接口与抽象类的关系  接口
 *
 * <p> 人抽象接口 </p>
 */
public abstract class AbstractPeople implements Animal {

    @Override
    public void cry() {
        System.out.println("我是人，我才不乱叫");
    }

    @Override
    public void fly(){
        System.out.println("我不会飞");
    }
    /** 吃 */
    @Override
    public abstract void eat();

    /** 走路 */
    @Override
    public abstract void walk();

    /** 说话交流 */
    @Override
    public abstract void speak();
}
```

在人的抽象类中实现了动物接口的部分方法，并提供了实现，然后再利用子类去继承这个抽象类，那么 `fly()` 这个接口就不需要在子类中重写，减少了代码的冗余并对代码进行了纬度划分（模板模式）。

需要注意的一点是，当抽象类继承接口的时候，抽象类不实现接口的方法，也不显示对方法进行抽象处理，这样子是不会报错的  例如：

```java
/**
 * @author BF
 * @date 2019/5/17 14:51
 * 测试接口与抽象类的关系  接口
 *
 * <p> 人抽象接口 </p>
 * 前面提到过，接口里面的方法实际是抽象方法，当用抽象类直接实现接口时，再用子类去继承它
 * 那么子类必须实现接口的全部实现，这个抽象类就没有用了。
 */

public abstract class AbstractPeople implements Animal {

}
```

前面提到过，接口里面的方法实际是抽象方法，当用抽象类直接实现接口时，再用子类去继承它，那么子类必须实现接口的全部实现，这个抽象类就没有用了。

引用码出高效里面的一句话：

> 当纠结定义接口还是抽象类时，优先推荐定义为接口，遵循接口的隔离原则，按某个纬度划分为多个接口，再用抽象类去实现这些接口，这样做可方便后续的扩展和重构